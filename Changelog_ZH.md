# 更新日志

## v0.1.5

- 允许编写js常见风格的setInterval自清理回调, 例如
    ```ts
    const h = setInterval(() => {
        f.printString('hello')
        if (condition) {
            clearInterval(h)
        }
    }, 1000)
    ```
- 允许在定时器回调内修改外部let声明的变量, 包括数组push等修改, 使其效果符合js语法直觉, 以方便许多常见用例, 先前版本会编译出错. 现在像这样的代码是可以正常编译的
    ```ts
    let acc = 5n
    const h = setInterval(() => {
        acc += 2n
        f.printString(str(acc))
        if (acc >= 9n) {
            clearInterval(h)
        }
    }, 1000)
    ```
- 修复先前版本中, 在定时器回调内, 使用嵌套回调导致变量没有正确捕获的问题, 例如
    ```ts
    setTimeout(() => {
        nums.forEach((v) => {
            f.printString(label)
            f.printString(str(v + base))
        })
    }, 200)
    ```
  情况下, 仅nums被捕获, 而label, base没有被正确捕获的问题
- 修复在定时器回调中, 调用函数时, 函数被错误地当作变量捕获, 引发的编译错误
- 数组foreach的回调函数参数, 不再强制要求, 允许为空

## v0.1.4

- 修复上个版本因为实体类型变得更加复杂, 导致的一些情况下eslint和定时器闭包捕获, 对实体类型显示错误的情况; 现在编译器的实体类型推断使用更智能的方式避免因为复杂的类型系统出错
- dev模式下, 外部编辑器保存地图时, 现在会自动重新注入数据, 意外覆盖时, 不再需要手动重新注入, 可以在配置中调整此设置
- 新增支持自动从地图中提取自定义元件的名称和id到代码, 方便定位操作对象和交互, 你可以在配置中调整开关和提取路径
- 添加更严格的超限模式和经典模式节点校验, 避免在使用快捷方法的情况下, 意外引入不可用的节点, 现在这种情况会直接提示错误
- eslint新增检查, 在定时器回调中, 直接访问外层事件参数的情况, 现在会显示警告, 引导进行修正

## v0.1.3

- 类型系统现在自动约束超限模式和经典模式可用的节点
- 支持dict(0), list(0), 等占位方法, 以便处理一些情况下, 节点参数引脚需要留空
- 为raw/float/int/guid/list/dict等辅助函数补充更详细的悬停注释说明, 和使用场景说明, 以便明确用途
- 新增一个经典模式下的节点`复苏当前场上角色`
- 修复`传送玩家`节点在经典模式下的创建异常

## v0.1.2

- g.server()支持传入mode字段, 控制超限模式和经典模式
- 新增6.3版本更新加入的14个新的服务器节点, 并添加相关的实体辅助属性和方法, 如.activeCharacter, .classicModeId等
- 类型系统目前尚未区分超限模式和经典模式可用的节点, 所有节点不分模式, 均可注入, 目前需要人为注意相关节点的使用

## v0.1.1

- 首次发布
